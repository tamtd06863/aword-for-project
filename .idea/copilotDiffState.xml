<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/(auth)/(learn)/learning/index.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/(auth)/(learn)/learning/index.tsx" />
              <option name="originalContent" value="import FlowPager from &quot;@/components/FlowPager&quot;;&#10;import NewWord from &quot;@/components/NewWord&quot;;&#10;import NewWordDetail from &quot;@/components/NewWordDetail&quot;;&#10;import QuizFourOptions from &quot;@/components/QuizFourOptions&quot;;&#10;import QuizResult from &quot;@/components/QuizResult&quot;;&#10;import {useGetQuestionsQuery} from &quot;@/lib/features/learn/learnApi&quot;;&#10;import {&#10;    useUpdateVocabsProgressMutation,&#10;    type QuestionResult,&#10;} from &quot;@/lib/features/vocab/vocabApi&quot;;&#10;import {getColors} from &quot;@/utls/colors&quot;;&#10;import {router} from &quot;expo-router&quot;;&#10;import {useColorScheme} from &quot;nativewind&quot;;&#10;import React from &quot;react&quot;;&#10;import {ActivityIndicator, Text, View} from &quot;react-native&quot;;&#10;&#10;const Index = () =&gt; {&#10;    const {colorScheme} = useColorScheme();&#10;    const colors = getColors(colorScheme === &quot;dark&quot;);&#10;    const [step, setStep] = React.useState(0);&#10;    const [currentQuestionIndex, setCurrentQuestionIndex] = React.useState(0);&#10;    const [selected, setSelected] = React.useState&lt;(number | null)[]&gt;([]);&#10;    const [checked, setChecked] = React.useState&lt;boolean[]&gt;([]);&#10;    // State để lưu kết quả từng câu trả lời (kèm thời gian)&#10;    const [questionResults, setQuestionResults] = React.useState&lt;&#10;        QuestionResult[]&#10;    &gt;([]);&#10;    // Track start time of current question&#10;    const [questionStartMs, setQuestionStartMs] = React.useState&lt;number&gt;(&#10;        Date.now(),&#10;    );&#10;    const [updateProgress, {isLoading: isUpdatingProgress}] =&#10;        useUpdateVocabsProgressMutation();&#10;&#10;    // Track session summary&#10;    const [expGained, setExpGained] = React.useState(0);&#10;    const [totalTimeSec, setTotalTimeSec] = React.useState(0);&#10;    const [maxStreak, setMaxStreak] = React.useState(0);&#10;&#10;    const {data: questionsData, isLoading: isGettingQuestions} =&#10;        useGetQuestionsQuery(undefined, {&#10;            refetchOnMountOrArgChange: true,&#10;        });&#10;&#10;    React.useEffect(() =&gt; {&#10;        if (questionsData?.questions) {&#10;            setSelected(Array(questionsData.questions.length).fill(null));&#10;            setChecked(Array(questionsData.questions.length).fill(false));&#10;            setCurrentQuestionIndex(0);&#10;            setQuestionResults([]);&#10;            setQuestionStartMs(Date.now());&#10;        }&#10;    }, [questionsData]);&#10;&#10;    // Reset timer when moving to a new question&#10;    React.useEffect(() =&gt; {&#10;        setQuestionStartMs(Date.now());&#10;    }, [currentQuestionIndex]);&#10;&#10;    if (isGettingQuestions || isUpdatingProgress) {&#10;        return (&#10;            &lt;View&#10;                className=&quot;flex-1 justify-center items-center&quot;&#10;                style={{backgroundColor: colors.background.primary}}&#10;            &gt;&#10;                &lt;ActivityIndicator size=&quot;large&quot; color={colors.primary.main}/&gt;&#10;            &lt;/View&gt;&#10;        );&#10;    }&#10;&#10;    if (!questionsData) {&#10;        return (&#10;            &lt;View&#10;                className=&quot;flex-1 justify-center items-center&quot;&#10;                style={{backgroundColor: colors.background.primary}}&#10;            &gt;&#10;                &lt;Text className=&quot;text-lg&quot; style={{color: colors.text.primary}}&gt;&#10;                    Failed to load questions. Please try again later.&#10;                &lt;/Text&gt;&#10;            &lt;/View&gt;&#10;        );&#10;    }&#10;&#10;    // Render only the current question&#10;    const question = questionsData.questions[currentQuestionIndex];&#10;    let options: string[] = [];&#10;    let correctIndex = 0;&#10;    if (&#10;        question.type === &quot;multiple_choice&quot; &amp;&amp;&#10;        Array.isArray(question.answer_blocks)&#10;    ) {&#10;        options = question.answer_blocks;&#10;        correctIndex = options.findIndex((opt) =&gt; opt === question.correct_answer);&#10;    } else if (&#10;        question.type === &quot;fill_in_blank&quot; &amp;&amp;&#10;        Array.isArray(question.answer_blocks)&#10;    ) {&#10;        options = question.answer_blocks;&#10;        correctIndex = options.findIndex((opt) =&gt; opt === question.correct_answer);&#10;    }&#10;&#10;    // Calculate total units: each new word counts as 1 unit, each quiz question counts as 1 unit&#10;    const totalWords = questionsData?.newWords?.length ?? 0;&#10;    const totalQuestions = questionsData?.questions?.length ?? 0;&#10;    const totalUnits = totalWords + totalQuestions;&#10;&#10;    // Map a unit index to normalized progress (0..1)&#10;    const getUnitProgress = (unitIndex: number) =&gt;&#10;        totalUnits &gt; 0&#10;            ? Math.max(0, Math.min(1, (unitIndex + 1) / totalUnits))&#10;            : 0;&#10;&#10;    // Helper to get word parts for NewWordDetail&#10;    const getWordParts = (word: any) =&gt; [&#10;        {text: word.prefix},&#10;        {text: &quot;·&quot;},&#10;        {text: word.infix},&#10;        {text: &quot;·&quot;},&#10;        {text: word.postfix},&#10;    ];&#10;&#10;    // Helper to get anatomy for NewWordDetail&#10;    const getAnatomy = (word: any) =&gt; [&#10;        {&#10;            badgeLabel: &quot;Prefix&quot;,&#10;            part: word.prefix,&#10;            meaning: word.prefix_meaning,&#10;        },&#10;        {&#10;            badgeLabel: &quot;Origin&quot;,&#10;            part: word.infix,&#10;            meaning: word.infix_meaning,&#10;        },&#10;        {&#10;            badgeLabel: &quot;Postfix&quot;,&#10;            part: word.postfix,&#10;            meaning: word.postfix_meaning,&#10;        },&#10;    ];&#10;&#10;    // Helper: format seconds as mm:ss&#10;    const formatTime = (secs: number) =&gt; {&#10;        const m = Math.floor(secs / 60).toString();&#10;        const s = (secs % 60).toString().padStart(2, &quot;0&quot;);&#10;        return `${m}:${s}`;&#10;    };&#10;&#10;    return (&#10;        &lt;View&#10;            className=&quot;flex-1&quot;&#10;            style={{backgroundColor: colors.background.primary}}&#10;        &gt;&#10;            &lt;FlowPager index={step}&gt;&#10;                {/* Dynamically render NewWord and NewWordDetail for each new word */}&#10;                {questionsData?.newWords?.map((word, idx) =&gt; [&#10;                    &lt;NewWord&#10;                        key={`newword-${word.id}`}&#10;                        word={word.word}&#10;                        progress={getUnitProgress(idx)}&#10;                        onContinue={() =&gt; setStep(idx * 2 + 1)}&#10;                    /&gt;,&#10;                    &lt;NewWordDetail&#10;                        key={`newworddetail-${word.id}`}&#10;                        progress={getUnitProgress(idx)}&#10;                        wordParts={getWordParts(word)}&#10;                        pos={word.vocab_senses[0]?.pos || &quot;&quot;}&#10;                        ipa={word.phonetic}&#10;                        viDefinition={word.vocab_senses[0]?.definition || &quot;&quot;}&#10;                        example={word.vocab_senses[0]?.word || &quot;&quot;}&#10;                        anatomy={getAnatomy(word)}&#10;                        onContinue={() =&gt; setStep(idx * 2 + 2)}&#10;                    /&gt;,&#10;                ])}&#10;&#10;                {/* Quiz step: after all words */}&#10;                &lt;QuizFourOptions&#10;                    progress={getUnitProgress(totalWords + currentQuestionIndex)}&#10;                    title={question.question}&#10;                    prompt={question.question}&#10;                    promptColorClass=&quot;text-red-600&quot;&#10;                    options={options}&#10;                    selectedIndex={selected[currentQuestionIndex]}&#10;                    onSelect={(i) =&gt; {&#10;                        const newSelected = [...selected];&#10;                        newSelected[currentQuestionIndex] = i;&#10;                        setSelected(newSelected);&#10;                        if (checked[currentQuestionIndex]) {&#10;                            const newChecked = [...checked];&#10;                            newChecked[currentQuestionIndex] = false;&#10;                            setChecked(newChecked);&#10;                            // restart timer if user changed selection after checking&#10;                            setQuestionStartMs(Date.now());&#10;                        }&#10;                    }}&#10;                    correctIndex={correctIndex}&#10;                    checked={checked[currentQuestionIndex]}&#10;                    onCheck={async () =&gt; {&#10;                        if (!checked[currentQuestionIndex]) {&#10;                            const newChecked = [...checked];&#10;                            newChecked[currentQuestionIndex] = true;&#10;                            setChecked(newChecked);&#10;&#10;                            // Lưu kết quả câu hỏi hiện tại với thời gian trả lời&#10;                            const userAnswerIndex = selected[currentQuestionIndex];&#10;                            const userAnswer =&#10;                                userAnswerIndex !== null ? options[userAnswerIndex] : &quot;&quot;;&#10;                            const isCorrect = userAnswer === question.correct_answer;&#10;                            const durationMs = Math.max(0, Date.now() - questionStartMs);&#10;                            const durationSec = Math.max(1, Math.round(durationMs / 1000));&#10;&#10;                            const newResult: QuestionResult = {&#10;                                question: question.question,&#10;                                userAnswer,&#10;                                correctAnswer: question.correct_answer,&#10;                                isCorrect,&#10;                                vocabId: question.vocab_id,&#10;                                durationSec,&#10;                            };&#10;&#10;                            setQuestionResults((prev) =&gt; [...prev, newResult]);&#10;                        } else {&#10;                            // Move to next question or show results&#10;                            if (currentQuestionIndex &lt; questionsData.questions.length - 1) {&#10;                                setCurrentQuestionIndex(currentQuestionIndex + 1);&#10;                            } else {&#10;                                // Submit progress to Supabase then show results&#10;                                try {&#10;                                    console.log(&quot;Submitting question results:&quot;, questionResults);&#10;                                    const res = await updateProgress({&#10;                                        questionResults,&#10;                                        allWords: questionsData.allWords,&#10;                                    }).unwrap();&#10;                                    // Save exp and total time&#10;                                    const total = questionResults.reduce(&#10;                                        (sum, r) =&gt; sum + (r.durationSec || 0),&#10;                                        0,&#10;                                    );&#10;                                    setTotalTimeSec(total);&#10;                                    setExpGained(res?.expGained ?? 0);&#10;                                    // Compute longest consecutive correct streak&#10;                                    let curr = 0;&#10;                                    let best = 0;&#10;                                    for (const r of questionResults) {&#10;                                        if (r.isCorrect) {&#10;                                            curr += 1;&#10;                                            if (curr &gt; best) best = curr;&#10;                                        } else {&#10;                                            curr = 0;&#10;                                        }&#10;                                    }&#10;                                    setMaxStreak(best);&#10;                                } catch {&#10;                                    // swallow error for now; could show a toast&#10;                                }&#10;                                setStep(totalWords * 2 + 1);&#10;                            }&#10;                        }&#10;                    }}&#10;                    checkLabel=&quot;Check&quot;&#10;                    continueLabel=&quot;Continue&quot;&#10;                    correctMessage=&quot;Chính xác&quot;&#10;                    incorrectMessage={`Đáp án đúng là: ${question.correct_answer}`}&#10;                /&gt;&#10;&#10;                {/* Result step: after quiz */}&#10;                &lt;QuizResult&#10;                    stats={[&#10;                        {&#10;                            icon: &quot;timer-outline&quot;,&#10;                            color: colors.accent.purple,&#10;                            text: `${formatTime(totalTimeSec)} - Super fast`,&#10;                        },&#10;                        {&#10;                            icon: &quot;flame-outline&quot;,&#10;                            color: colors.accent.red,&#10;                            text: `${maxStreak} in a row`,&#10;                        },&#10;                        {&#10;                            icon: &quot;flash-outline&quot;,&#10;                            color: colors.accent.yellow,&#10;                            text: `${expGained} exp`,&#10;                        },&#10;                    ]}&#10;                    onContinue={() =&gt; router.back()}&#10;                /&gt;&#10;            &lt;/FlowPager&gt;&#10;        &lt;/View&gt;&#10;    );&#10;};&#10;&#10;export default Index;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;};&#10;&#10;export default Index;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="import FlowPager from &quot;@/components/FlowPager&quot;;&#10;import NewWord from &quot;@/components/NewWord&quot;;&#10;import NewWordDetail from &quot;@/components/NewWordDetail&quot;;&#10;import QuizFourOptions from &quot;@/components/QuizFourOptions&quot;;&#10;import QuizResult from &quot;@/components/QuizResult&quot;;&#10;import { useGetQuestionsQuery } from &quot;@/lib/features/learn/learnApi&quot;;&#10;import {&#10;  useUpdateVocabsProgressMutation,&#10;  type QuestionResult,&#10;} from &quot;@/lib/features/vocab/vocabApi&quot;;&#10;import { getColors } from &quot;@/utls/colors&quot;;&#10;import { router } from &quot;expo-router&quot;;&#10;import { useColorScheme } from &quot;nativewind&quot;;&#10;import React from &quot;react&quot;;&#10;import { ActivityIndicator, Text, View } from &quot;react-native&quot;;&#10;&#10;const Index = () =&gt; {&#10;  const { colorScheme } = useColorScheme();&#10;  const colors = getColors(colorScheme === &quot;dark&quot;);&#10;  const [step, setStep] = React.useState(0);&#10;  const [currentQuestionIndex, setCurrentQuestionIndex] = React.useState(0);&#10;  const [selected, setSelected] = React.useState&lt;(number | null)[]&gt;([]);&#10;  const [checked, setChecked] = React.useState&lt;boolean[]&gt;([]);&#10;  // Lưu kết quả cho mỗi lần trả lời (bao gồm thời gian)&#10;  const [questionResults, setQuestionResults] = React.useState&lt;QuestionResult[]&gt;(&#10;    []&#10;  );&#10;  // Bắt đầu tính thời gian cho câu hiện tại&#10;  const [questionStartMs, setQuestionStartMs] = React.useState&lt;number&gt;(&#10;    Date.now()&#10;  );&#10;  const [updateProgress, { isLoading: isUpdatingProgress }] =&#10;    useUpdateVocabsProgressMutation();&#10;&#10;  // Tổng kết session&#10;  const [expGained, setExpGained] = React.useState(0);&#10;  const [totalTimeSec, setTotalTimeSec] = React.useState(0);&#10;  const [maxStreak, setMaxStreak] = React.useState(0);&#10;&#10;  // Hàng đợi câu hỏi để lặp lại câu sai&#10;  const [questionQueue, setQuestionQueue] = React.useState&lt;number[]&gt;([]);&#10;&#10;  const { data: questionsData, isLoading: isGettingQuestions } =&#10;    useGetQuestionsQuery(undefined, {&#10;      refetchOnMountOrArgChange: true,&#10;    });&#10;&#10;  React.useEffect(() =&gt; {&#10;    if (questionsData?.questions) {&#10;      setSelected(Array(questionsData.questions.length).fill(null));&#10;      setChecked(Array(questionsData.questions.length).fill(false));&#10;      setCurrentQuestionIndex(0);&#10;      setQuestionResults([]);&#10;      setQuestionStartMs(Date.now());&#10;      // Khởi tạo hàng đợi: 0..n-1&#10;      setQuestionQueue(questionsData.questions.map((_, i) =&gt; i));&#10;    }&#10;  }, [questionsData]);&#10;&#10;  // Đồng bộ chỉ số câu hiện tại theo phần tử đầu của hàng đợi&#10;  React.useEffect(() =&gt; {&#10;    if (questionQueue.length &gt; 0) {&#10;      setCurrentQuestionIndex(questionQueue[0]);&#10;    }&#10;  }, [questionQueue]);&#10;&#10;  // Reset timer khi chuyển câu&#10;  React.useEffect(() =&gt; {&#10;    setQuestionStartMs(Date.now());&#10;  }, [currentQuestionIndex]);&#10;&#10;  if (isGettingQuestions || isUpdatingProgress) {&#10;    return (&#10;      &lt;View&#10;        className=&quot;flex-1 justify-center items-center&quot;&#10;        style={{ backgroundColor: colors.background.primary }}&#10;      &gt;&#10;        &lt;ActivityIndicator size=&quot;large&quot; color={colors.primary.main} /&gt;&#10;      &lt;/View&gt;&#10;    );&#10;  }&#10;&#10;  if (!questionsData) {&#10;    return (&#10;      &lt;View&#10;        className=&quot;flex-1 justify-center items-center&quot;&#10;        style={{ backgroundColor: colors.background.primary }}&#10;      &gt;&#10;        &lt;Text className=&quot;text-lg&quot; style={{ color: colors.text.primary }}&gt;&#10;          Failed to load questions. Please try again later.&#10;        &lt;/Text&gt;&#10;      &lt;/View&gt;&#10;    );&#10;  }&#10;&#10;  const totalWords = questionsData?.newWords?.length ?? 0;&#10;  const totalQuestions = questionsData?.questions?.length ?? 0;&#10;  const totalUnits = totalWords + totalQuestions;&#10;  const hasQuestions = totalQuestions &gt; 0;&#10;&#10;  // Progress helper: 0..1 theo tổng unit (words + mastered questions)&#10;  const getUnitProgress = (unitIndex: number) =&gt;&#10;    totalUnits &gt; 0 ? Math.max(0, Math.min(1, (unitIndex + 1) / totalUnits)) : 0;&#10;&#10;  // Số câu đã master = tổng câu - số còn trong hàng đợi&#10;  const masteredCount = Math.max(0, totalQuestions - questionQueue.length);&#10;  const overallProgress =&#10;    totalUnits &gt; 0 ? (totalWords + masteredCount) / totalUnits : 0;&#10;&#10;  // Helper: format seconds as mm:ss&#10;  const formatTime = (secs: number) =&gt; {&#10;    const m = Math.floor(secs / 60).toString();&#10;    const s = (secs % 60).toString().padStart(2, &quot;0&quot;);&#10;    return `${m}:${s}`;&#10;  };&#10;&#10;  return (&#10;    &lt;View className=&quot;flex-1&quot; style={{ backgroundColor: colors.background.primary }}&gt;&#10;      &lt;FlowPager index={step}&gt;&#10;        {/* New words pages */}&#10;        {questionsData?.newWords?.map((word, idx) =&gt; [&#10;          &lt;NewWord&#10;            key={`newword-${word.id}`}&#10;            word={word.word}&#10;            progress={getUnitProgress(idx)}&#10;            onContinue={() =&gt; setStep(idx * 2 + 1)}&#10;          /&gt;,&#10;          &lt;NewWordDetail&#10;            key={`newworddetail-${word.id}`}&#10;            progress={getUnitProgress(idx)}&#10;            wordParts={[&#10;              { text: word.prefix },&#10;              { text: &quot;·&quot; },&#10;              { text: word.infix },&#10;              { text: &quot;·&quot; },&#10;              { text: word.postfix },&#10;            ]}&#10;            pos={word.vocab_senses[0]?.pos || &quot;&quot;}&#10;            ipa={word.phonetic}&#10;            viDefinition={word.vocab_senses[0]?.definition || &quot;&quot;}&#10;            example={word.vocab_senses[0]?.word || &quot;&quot;}&#10;            anatomy={[&#10;              { badgeLabel: &quot;Prefix&quot;, part: word.prefix, meaning: word.prefix_meaning },&#10;              { badgeLabel: &quot;Origin&quot;, part: word.infix, meaning: word.infix_meaning },&#10;              { badgeLabel: &quot;Postfix&quot;, part: word.postfix, meaning: word.postfix_meaning },&#10;            ]}&#10;            onContinue={() =&gt; setStep(idx * 2 + 2)}&#10;          /&gt;,&#10;        ])}&#10;&#10;        {/* Quiz step: only render if there are questions */}&#10;        {hasQuestions ? (&#10;          (() =&gt; {&#10;            const q = questionsData.questions[currentQuestionIndex];&#10;            const opts = Array.isArray(q.answer_blocks) ? q.answer_blocks : [];&#10;            const correctIndex = opts.findIndex((opt) =&gt; opt === q.correct_answer);&#10;            return (&#10;              &lt;QuizFourOptions&#10;                key={`quiz-${currentQuestionIndex}`}&#10;                progress={overallProgress}&#10;                title={q.question}&#10;                prompt={q.question}&#10;                promptColorClass=&quot;text-red-600&quot;&#10;                options={opts}&#10;                selectedIndex={selected[currentQuestionIndex]}&#10;                onSelect={(i) =&gt; {&#10;                  const newSelected = [...selected];&#10;                  newSelected[currentQuestionIndex] = i;&#10;                  setSelected(newSelected);&#10;                  if (checked[currentQuestionIndex]) {&#10;                    const newChecked = [...checked];&#10;                    newChecked[currentQuestionIndex] = false;&#10;                    setChecked(newChecked);&#10;                    setQuestionStartMs(Date.now());&#10;                  }&#10;                }}&#10;                correctIndex={correctIndex}&#10;                checked={checked[currentQuestionIndex]}&#10;                onCheck={async () =&gt; {&#10;                  if (!checked[currentQuestionIndex]) {&#10;                    const newChecked = [...checked];&#10;                    newChecked[currentQuestionIndex] = true;&#10;                    setChecked(newChecked);&#10;&#10;                    const userAnswerIndex = selected[currentQuestionIndex];&#10;                    const userAnswer =&#10;                      userAnswerIndex !== null &amp;&amp; userAnswerIndex !== undefined&#10;                        ? opts[userAnswerIndex]&#10;                        : &quot;&quot;;&#10;                    const isCorrect = userAnswer === q.correct_answer;&#10;                    const durationMs = Math.max(0, Date.now() - questionStartMs);&#10;                    const durationSec = Math.max(1, Math.round(durationMs / 1000));&#10;&#10;                    const newResult: QuestionResult = {&#10;                      question: q.question,&#10;                      userAnswer,&#10;                      correctAnswer: q.correct_answer,&#10;                      isCorrect,&#10;                      vocabId: q.vocab_id,&#10;                      durationSec,&#10;                    };&#10;&#10;                    setQuestionResults((prev) =&gt; [...prev, newResult]);&#10;                  } else {&#10;                    // Continue -&gt; cập nhật hàng đợi&#10;                    const userAnswerIndex = selected[currentQuestionIndex];&#10;                    const userAnswer =&#10;                      userAnswerIndex !== null &amp;&amp; userAnswerIndex !== undefined&#10;                        ? opts[userAnswerIndex]&#10;                        : &quot;&quot;;&#10;                    const isCorrect = userAnswer === q.correct_answer;&#10;&#10;                    setQuestionQueue((prev) =&gt; {&#10;                      if (prev.length === 0) return prev;&#10;                      const [head, ...rest] = prev;&#10;&#10;                      // Clear trạng thái cho lần lặp lại&#10;                      setChecked((c) =&gt; {&#10;                        const cp = [...c];&#10;                        cp[head] = false;&#10;                        return cp;&#10;                      });&#10;                      setSelected((s) =&gt; {&#10;                        const cp = [...s];&#10;                        cp[head] = null;&#10;                        return cp;&#10;                      });&#10;&#10;                      if (isCorrect) {&#10;                        const newQueue = rest;&#10;                        if (newQueue.length === 0) {&#10;                          (async () =&gt; {&#10;                            try {&#10;                              const res = await updateProgress({&#10;                                questionResults,&#10;                                allWords: questionsData.allWords,&#10;                              }).unwrap();&#10;                              const total = questionResults.reduce(&#10;                                (sum, r) =&gt; sum + (r.durationSec || 0),&#10;                                0&#10;                              );&#10;                              setTotalTimeSec(total);&#10;                              setExpGained(res?.expGained ?? 0);&#10;                              let curr = 0;&#10;                              let best = 0;&#10;                              for (const r of questionResults) {&#10;                                if (r.isCorrect) {&#10;                                  curr += 1;&#10;                                  if (curr &gt; best) best = curr;&#10;                                } else {&#10;                                  curr = 0;&#10;                                }&#10;                              }&#10;                              setMaxStreak(best);&#10;                            } catch {&#10;                              // ignore&#10;                            }&#10;                            setStep(totalWords * 2 + 1);&#10;                          })();&#10;                        }&#10;                        return newQueue;&#10;                      }&#10;                      // Trả lời sai -&gt; đẩy xuống cuối&#10;                      return [...rest, head];&#10;                    });&#10;                  }&#10;                }}&#10;                checkLabel=&quot;Check&quot;&#10;                continueLabel=&quot;Continue&quot;&#10;                correctMessage=&quot;Chính xác&quot;&#10;                incorrectMessage={&#10;                  &quot;Đáp án đúng là: &quot; +&#10;                  (questionsData.questions[currentQuestionIndex]?.correct_answer ?? &quot;&quot;)&#10;                }&#10;              /&gt;&#10;            );&#10;          })()&#10;        ) : null}&#10;&#10;        {/* Result step */}&#10;        &lt;QuizResult&#10;          stats={[&#10;            {&#10;              icon: &quot;timer-outline&quot;,&#10;              color: colors.accent.purple,&#10;              text: `${formatTime(totalTimeSec)} - Super fast`,&#10;            },&#10;            {&#10;              icon: &quot;flame-outline&quot;,&#10;              color: colors.accent.red,&#10;              text: `${maxStreak} in a row`,&#10;            },&#10;            {&#10;              icon: &quot;flash-outline&quot;,&#10;              color: colors.accent.yellow,&#10;              text: `${expGained} exp`,&#10;            },&#10;          ]}&#10;          onContinue={() =&gt; router.back()}&#10;        /&gt;&#10;      &lt;/FlowPager&gt;&#10;    &lt;/View&gt;&#10;  );&#10;};&#10;&#10;export default Index;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>